import{S as je,i as Pe,s as We,k as e,q as n,a as l,y as Je,l as r,m as o,r as i,h as a,c as h,z as Ue,n as p,p as Ye,J as ve,b as be,G as t,A as Ke,H as Qe,g as Xe,d as Ze,B as tr,o as er}from"../chunks/index.e5a23430.mjs";import{N as rr}from"../chunks/Navbar.200d44ba.mjs";import{c as Oe}from"../chunks/units.13f9e7fa.mjs";function ar(_e){let f,H,rt,tt,v,k,at,s,V,nt,it,$,ot,st,_,lt,ht,ct,dt,d,N,pt,ut,O,mt,gt,C,ft,vt,j,bt,_t,P,yt,It,W,Bt,Et,J,wt,Rt,U,kt,Dt,Lt,x,Tt,Ft,g,Vt,$t,xt,At,zt,qt,Mt,I,Y,St,Gt,K,Ht,Nt,Q,Ot,Ct,jt,A,Pt,Wt,b,Jt,Ut,Yt,Kt,Qt,Xt,Zt,D,ye,te,z,ee,re,B,ae,ne,ie,oe,se,q,le,he,E,ce,de,pe,ue,me,L,M,Ie,ge,T,Be,fe,et;return k=new rr({}),{c(){f=e("head"),H=e("title"),rt=n("Home"),tt=l(),v=e("body"),Je(k.$$.fragment),at=l(),s=e("div"),V=e("div"),nt=n("Brainf**k Interpreter"),it=l(),$=e("div"),ot=n("What is Brainf**k?"),st=l(),_=e("div"),lt=n(`Brainf**k (BF) is an esolang centred around a single array of bytes
            `),ht=e("br"),ct=e("br"),dt=n(`
            There are only 8 operators in BF:
            `),d=e("ul"),N=e("li"),pt=n("> Increment the pointer position"),ut=l(),O=e("li"),mt=n("< Deincrement the pointer position"),gt=l(),C=e("li"),ft=n("+ Increment the byte at the pointer"),vt=l(),j=e("li"),bt=n("- Deincrement the byte at the pointer"),_t=l(),P=e("li"),yt=n(". Output the byte at the data pointer"),It=l(),W=e("li"),Bt=n(", Accept one byte of input, storing it in the byte at the pointer"),Et=l(),J=e("li"),wt=n("[ If the byte at the pointer is zero, goto the corresponding ] operator"),Rt=l(),U=e("li"),kt=n("] If the byte at the pointer is nonzero, goto the corresponding [ operator"),Dt=n(`
            Despite only having these 8 operators BF is (with an infinitely large array) turing complete`),Lt=l(),x=e("div"),Tt=n("Implementing Brainf**k"),Ft=l(),g=e("div"),Vt=n(`Around the time that I found out about BF I was also learning the programming language Rust
            `),$t=e("br"),xt=e("br"),At=n(`
            I decided to write my BF interpreter in Rust as it provided a great opportunity to start
            getting to grips with Rust's match statements and iterators
            `),zt=e("br"),qt=e("br"),Mt=n(`
            My brainf**k interpreter has 3 main parts:
            `),I=e("ol"),Y=e("li"),St=n("Read and parse the program"),Gt=l(),K=e("li"),Ht=n("Read input"),Nt=l(),Q=e("li"),Ot=n("Interpret the program"),Ct=n(`
            Lets break down how I solved each of these presentations`),jt=l(),A=e("div"),Pt=n("Reading and parsing the program"),Wt=l(),b=e("div"),Jt=n(`The program functions as an interactive session interpreter,
            so it will keep taking lines of user input from the terminal until the user enters "run"
            `),Ut=e("br"),Yt=e("br"),Kt=n(`
            For every line of user input the program will iterate through all the characters 
            and filter out any that aren't one of the 8 operators
            `),Qt=e("br"),Xt=e("br"),Zt=l(),D=e("img"),te=l(),z=e("div"),ee=n("Reading user input"),re=l(),B=e("div"),ae=n(`I made the design decision of having all user input entered before the program is interpreted. 
            `),ne=e("br"),ie=e("br"),oe=n(`
            This meant that all input could be entered quickly on a single line`),se=l(),q=e("div"),le=n("Interpreting the program"),he=l(),E=e("div"),ce=n(`The program uses a while loop to keep running through the characters in the program 
            until the end has been reached
            `),de=e("br"),pe=e("br"),ue=n(`
            Inside the while loop a match statement is used to match the current 
            operator to the current code to run for that operator`),me=l(),L=e("a"),M=e("img"),ge=l(),T=e("script"),fe=l(),this.h()},l(m){f=r(m,"HEAD",{});var S=o(f);H=r(S,"TITLE",{});var Ee=o(H);rt=i(Ee,"Home"),Ee.forEach(a),S.forEach(a),tt=h(m),v=r(m,"BODY",{});var w=o(v);Ue(k.$$.fragment,w),at=h(w),s=r(w,"DIV",{class:!0});var c=o(s);V=r(c,"DIV",{class:!0});var we=o(V);nt=i(we,"Brainf**k Interpreter"),we.forEach(a),it=h(c),$=r(c,"DIV",{class:!0});var Re=o($);ot=i(Re,"What is Brainf**k?"),Re.forEach(a),st=h(c),_=r(c,"DIV",{class:!0});var F=o(_);lt=i(F,`Brainf**k (BF) is an esolang centred around a single array of bytes
            `),ht=r(F,"BR",{}),ct=r(F,"BR",{}),dt=i(F,`
            There are only 8 operators in BF:
            `),d=r(F,"UL",{class:!0});var u=o(d);N=r(u,"LI",{});var ke=o(N);pt=i(ke,"> Increment the pointer position"),ke.forEach(a),ut=h(u),O=r(u,"LI",{});var De=o(O);mt=i(De,"< Deincrement the pointer position"),De.forEach(a),gt=h(u),C=r(u,"LI",{});var Le=o(C);ft=i(Le,"+ Increment the byte at the pointer"),Le.forEach(a),vt=h(u),j=r(u,"LI",{});var Te=o(j);bt=i(Te,"- Deincrement the byte at the pointer"),Te.forEach(a),_t=h(u),P=r(u,"LI",{});var Fe=o(P);yt=i(Fe,". Output the byte at the data pointer"),Fe.forEach(a),It=h(u),W=r(u,"LI",{});var Ve=o(W);Bt=i(Ve,", Accept one byte of input, storing it in the byte at the pointer"),Ve.forEach(a),Et=h(u),J=r(u,"LI",{});var $e=o(J);wt=i($e,"[ If the byte at the pointer is zero, goto the corresponding ] operator"),$e.forEach(a),Rt=h(u),U=r(u,"LI",{});var xe=o(U);kt=i(xe,"] If the byte at the pointer is nonzero, goto the corresponding [ operator"),xe.forEach(a),u.forEach(a),Dt=i(F,`
            Despite only having these 8 operators BF is (with an infinitely large array) turing complete`),F.forEach(a),Lt=h(c),x=r(c,"DIV",{class:!0});var Ae=o(x);Tt=i(Ae,"Implementing Brainf**k"),Ae.forEach(a),Ft=h(c),g=r(c,"DIV",{class:!0});var y=o(g);Vt=i(y,`Around the time that I found out about BF I was also learning the programming language Rust
            `),$t=r(y,"BR",{}),xt=r(y,"BR",{}),At=i(y,`
            I decided to write my BF interpreter in Rust as it provided a great opportunity to start
            getting to grips with Rust's match statements and iterators
            `),zt=r(y,"BR",{}),qt=r(y,"BR",{}),Mt=i(y,`
            My brainf**k interpreter has 3 main parts:
            `),I=r(y,"OL",{});var G=o(I);Y=r(G,"LI",{});var ze=o(Y);St=i(ze,"Read and parse the program"),ze.forEach(a),Gt=h(G),K=r(G,"LI",{});var qe=o(K);Ht=i(qe,"Read input"),qe.forEach(a),Nt=h(G),Q=r(G,"LI",{});var Me=o(Q);Ot=i(Me,"Interpret the program"),Me.forEach(a),G.forEach(a),Ct=i(y,`
            Lets break down how I solved each of these presentations`),y.forEach(a),jt=h(c),A=r(c,"DIV",{class:!0});var Se=o(A);Pt=i(Se,"Reading and parsing the program"),Se.forEach(a),Wt=h(c),b=r(c,"DIV",{class:!0});var R=o(b);Jt=i(R,`The program functions as an interactive session interpreter,
            so it will keep taking lines of user input from the terminal until the user enters "run"
            `),Ut=r(R,"BR",{}),Yt=r(R,"BR",{}),Kt=i(R,`
            For every line of user input the program will iterate through all the characters 
            and filter out any that aren't one of the 8 operators
            `),Qt=r(R,"BR",{}),Xt=r(R,"BR",{}),Zt=h(R),D=r(R,"IMG",{style:!0,src:!0,alt:!0}),R.forEach(a),te=h(c),z=r(c,"DIV",{class:!0});var Ge=o(z);ee=i(Ge,"Reading user input"),Ge.forEach(a),re=h(c),B=r(c,"DIV",{class:!0});var X=o(B);ae=i(X,`I made the design decision of having all user input entered before the program is interpreted. 
            `),ne=r(X,"BR",{}),ie=r(X,"BR",{}),oe=i(X,`
            This meant that all input could be entered quickly on a single line`),X.forEach(a),se=h(c),q=r(c,"DIV",{class:!0});var He=o(q);le=i(He,"Interpreting the program"),He.forEach(a),he=h(c),E=r(c,"DIV",{class:!0});var Z=o(E);ce=i(Z,`The program uses a while loop to keep running through the characters in the program 
            until the end has been reached
            `),de=r(Z,"BR",{}),pe=r(Z,"BR",{}),ue=i(Z,`
            Inside the while loop a match statement is used to match the current 
            operator to the current code to run for that operator`),Z.forEach(a),c.forEach(a),me=h(w),L=r(w,"A",{title:!0,href:!0});var Ne=o(L);M=r(Ne,"IMG",{alt:!0,src:!0}),Ne.forEach(a),ge=h(w),T=r(w,"SCRIPT",{src:!0});var Ce=o(T);Ce.forEach(a),fe=h(w),w.forEach(a),this.h()},h(){p(V,"class","title"),p($,"class","header"),p(d,"class","no_dot"),p(_,"class","text"),p(x,"class","header"),p(g,"class","text"),p(A,"class","sub_header"),Ye(D,"width","25rem"),ve(D.src,ye="/images/brainfuck/iterator.png")||p(D,"src",ye),p(D,"alt","Rust code showing iterator I used"),p(b,"class","text"),p(z,"class","sub_header"),p(B,"class","text"),p(q,"class","sub_header"),p(E,"class","text"),p(s,"class","content"),p(M,"alt","Clicky"),ve(M.src,Ie="//static.getclicky.com/media/links/badge.gif")||p(M,"src",Ie),p(L,"title","Google Analytics Alternative"),p(L,"href","https://clicky.com/101402447"),T.async=!0,ve(T.src,Be="//static.getclicky.com/101402447.js")||p(T,"src",Be)},m(m,S){be(m,f,S),t(f,H),t(H,rt),be(m,tt,S),be(m,v,S),Ke(k,v,null),t(v,at),t(v,s),t(s,V),t(V,nt),t(s,it),t(s,$),t($,ot),t(s,st),t(s,_),t(_,lt),t(_,ht),t(_,ct),t(_,dt),t(_,d),t(d,N),t(N,pt),t(d,ut),t(d,O),t(O,mt),t(d,gt),t(d,C),t(C,ft),t(d,vt),t(d,j),t(j,bt),t(d,_t),t(d,P),t(P,yt),t(d,It),t(d,W),t(W,Bt),t(d,Et),t(d,J),t(J,wt),t(d,Rt),t(d,U),t(U,kt),t(_,Dt),t(s,Lt),t(s,x),t(x,Tt),t(s,Ft),t(s,g),t(g,Vt),t(g,$t),t(g,xt),t(g,At),t(g,zt),t(g,qt),t(g,Mt),t(g,I),t(I,Y),t(Y,St),t(I,Gt),t(I,K),t(K,Ht),t(I,Nt),t(I,Q),t(Q,Ot),t(g,Ct),t(s,jt),t(s,A),t(A,Pt),t(s,Wt),t(s,b),t(b,Jt),t(b,Ut),t(b,Yt),t(b,Kt),t(b,Qt),t(b,Xt),t(b,Zt),t(b,D),t(s,te),t(s,z),t(z,ee),t(s,re),t(s,B),t(B,ae),t(B,ne),t(B,ie),t(B,oe),t(s,se),t(s,q),t(q,le),t(s,he),t(s,E),t(E,ce),t(E,de),t(E,pe),t(E,ue),t(v,me),t(v,L),t(L,M),t(v,ge),t(v,T),t(v,fe),et=!0},p:Qe,i(m){et||(Xe(k.$$.fragment,m),et=!0)},o(m){Ze(k.$$.fragment,m),et=!1},d(m){m&&a(f),m&&a(tt),m&&a(v),tr(k)}}}function nr(_e){let f;return er(()=>{f=Oe(window),document.getElementsByTagName("html")[0].style.fontSize=`${f}vw`,window.addEventListener("resize",()=>{f=Oe(window),document.getElementsByTagName("html")[0].style.fontSize=`${f}vw`})}),[]}class lr extends je{constructor(f){super(),Pe(this,f,nr,ar,We,{})}}export{lr as default};
