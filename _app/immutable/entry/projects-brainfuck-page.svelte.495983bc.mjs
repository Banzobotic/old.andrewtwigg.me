import{S as xt,i as zt,s as At,k as t,q as n,a as h,y as qt,l as r,m as o,r as a,h as i,c as d,z as Ht,n as m,p as Mt,J as Nt,b as ct,G as e,A as Ot,H as St,g as Gt,d as Wt,B as jt,o as Ct}from"../chunks/index.e5a23430.mjs";import{N as Jt}from"../chunks/Navbar.200d44ba.mjs";import{c as $t}from"../chunks/units.13f9e7fa.mjs";function Pt(pt){let f,q,Z,K,w,R,ee,s,L,te,re,F,ne,ae,b,ie,oe,se,le,c,H,he,de,M,ce,pe,N,ue,me,O,ge,fe,S,ve,be,G,_e,Ie,W,ye,Be,j,Ee,we,Re,T,ke,De,g,Le,Fe,Te,Ve,$e,xe,ze,I,C,Ae,qe,J,He,Me,P,Ne,Oe,Se,V,Ge,We,v,je,Ce,Je,Pe,Ue,Ye,Ke,k,ut,Qe,$,Xe,Ze,y,et,tt,rt,nt,at,x,it,ot,B,st,lt,ht,dt,Q;return R=new Jt({}),{c(){f=t("head"),q=t("title"),Z=n("Home"),K=h(),w=t("body"),qt(R.$$.fragment),ee=h(),s=t("div"),L=t("div"),te=n("Brainf**k Interpreter"),re=h(),F=t("div"),ne=n("What is Brainf**k?"),ae=h(),b=t("div"),ie=n(`Brainf**k (BF) is an esolang centred around a single array of bytes
            `),oe=t("br"),se=t("br"),le=n(`
            There are only 8 operators in BF:
            `),c=t("ul"),H=t("li"),he=n("> Increment the pointer position"),de=h(),M=t("li"),ce=n("< Deincrement the pointer position"),pe=h(),N=t("li"),ue=n("+ Increment the byte at the pointer"),me=h(),O=t("li"),ge=n("- Deincrement the byte at the pointer"),fe=h(),S=t("li"),ve=n(". Output the byte at the data pointer"),be=h(),G=t("li"),_e=n(", Accept one byte of input, storing it in the byte at the pointer"),Ie=h(),W=t("li"),ye=n("[ If the byte at the pointer is zero, goto the corresponding ] operator"),Be=h(),j=t("li"),Ee=n("] If the byte at the pointer is nonzero, goto the corresponding [ operator"),we=n(`
            Despite only having these 8 operators BF is (with an infinitely large array) turing complete`),Re=h(),T=t("div"),ke=n("Implementing Brainf**k"),De=h(),g=t("div"),Le=n(`Around the time that I found out about BF I was also learning the programming language Rust
            `),Fe=t("br"),Te=t("br"),Ve=n(`
            I decided to write my BF interpreter in Rust as it provided a great opportunity to start
            getting to grips with Rust's match statements and iterators
            `),$e=t("br"),xe=t("br"),ze=n(`
            My brainf**k interpreter has 3 main parts:
            `),I=t("ol"),C=t("li"),Ae=n("Read and parse the program"),qe=h(),J=t("li"),He=n("Read input"),Me=h(),P=t("li"),Ne=n("Interpret the program"),Oe=n(`
            Lets break down how I solved each of these presentations`),Se=h(),V=t("div"),Ge=n("Reading and parsing the program"),We=h(),v=t("div"),je=n(`The program functions as an interactive session interpreter,
            so it will keep taking lines of user input from the terminal until the user enters "run"
            `),Ce=t("br"),Je=t("br"),Pe=n(`
            For every line of user input the program will iterate through all the characters 
            and filter out any that aren't one of the 8 operators
            `),Ue=t("br"),Ye=t("br"),Ke=h(),k=t("img"),Qe=h(),$=t("div"),Xe=n("Reading user input"),Ze=h(),y=t("div"),et=n(`I made the design decision of having all user input entered before the program is interpreted. 
            `),tt=t("br"),rt=t("br"),nt=n(`
            This meant that all input could be entered quickly on a single line`),at=h(),x=t("div"),it=n("Interpreting the program"),ot=h(),B=t("div"),st=n(`The program uses a while loop to keep running through the characters in the program 
            until the end has been reached
            `),lt=t("br"),ht=t("br"),dt=n(`
            Inside the while loop a match statement is used to match the current 
            operator to the current code to run for that operator`),this.h()},l(u){f=r(u,"HEAD",{});var z=o(f);q=r(z,"TITLE",{});var mt=o(q);Z=a(mt,"Home"),mt.forEach(i),z.forEach(i),K=d(u),w=r(u,"BODY",{});var X=o(w);Ht(R.$$.fragment,X),ee=d(X),s=r(X,"DIV",{class:!0});var l=o(s);L=r(l,"DIV",{class:!0});var gt=o(L);te=a(gt,"Brainf**k Interpreter"),gt.forEach(i),re=d(l),F=r(l,"DIV",{class:!0});var ft=o(F);ne=a(ft,"What is Brainf**k?"),ft.forEach(i),ae=d(l),b=r(l,"DIV",{class:!0});var D=o(b);ie=a(D,`Brainf**k (BF) is an esolang centred around a single array of bytes
            `),oe=r(D,"BR",{}),se=r(D,"BR",{}),le=a(D,`
            There are only 8 operators in BF:
            `),c=r(D,"UL",{class:!0});var p=o(c);H=r(p,"LI",{});var vt=o(H);he=a(vt,"> Increment the pointer position"),vt.forEach(i),de=d(p),M=r(p,"LI",{});var bt=o(M);ce=a(bt,"< Deincrement the pointer position"),bt.forEach(i),pe=d(p),N=r(p,"LI",{});var _t=o(N);ue=a(_t,"+ Increment the byte at the pointer"),_t.forEach(i),me=d(p),O=r(p,"LI",{});var It=o(O);ge=a(It,"- Deincrement the byte at the pointer"),It.forEach(i),fe=d(p),S=r(p,"LI",{});var yt=o(S);ve=a(yt,". Output the byte at the data pointer"),yt.forEach(i),be=d(p),G=r(p,"LI",{});var Bt=o(G);_e=a(Bt,", Accept one byte of input, storing it in the byte at the pointer"),Bt.forEach(i),Ie=d(p),W=r(p,"LI",{});var Et=o(W);ye=a(Et,"[ If the byte at the pointer is zero, goto the corresponding ] operator"),Et.forEach(i),Be=d(p),j=r(p,"LI",{});var wt=o(j);Ee=a(wt,"] If the byte at the pointer is nonzero, goto the corresponding [ operator"),wt.forEach(i),p.forEach(i),we=a(D,`
            Despite only having these 8 operators BF is (with an infinitely large array) turing complete`),D.forEach(i),Re=d(l),T=r(l,"DIV",{class:!0});var Rt=o(T);ke=a(Rt,"Implementing Brainf**k"),Rt.forEach(i),De=d(l),g=r(l,"DIV",{class:!0});var _=o(g);Le=a(_,`Around the time that I found out about BF I was also learning the programming language Rust
            `),Fe=r(_,"BR",{}),Te=r(_,"BR",{}),Ve=a(_,`
            I decided to write my BF interpreter in Rust as it provided a great opportunity to start
            getting to grips with Rust's match statements and iterators
            `),$e=r(_,"BR",{}),xe=r(_,"BR",{}),ze=a(_,`
            My brainf**k interpreter has 3 main parts:
            `),I=r(_,"OL",{});var A=o(I);C=r(A,"LI",{});var kt=o(C);Ae=a(kt,"Read and parse the program"),kt.forEach(i),qe=d(A),J=r(A,"LI",{});var Dt=o(J);He=a(Dt,"Read input"),Dt.forEach(i),Me=d(A),P=r(A,"LI",{});var Lt=o(P);Ne=a(Lt,"Interpret the program"),Lt.forEach(i),A.forEach(i),Oe=a(_,`
            Lets break down how I solved each of these presentations`),_.forEach(i),Se=d(l),V=r(l,"DIV",{class:!0});var Ft=o(V);Ge=a(Ft,"Reading and parsing the program"),Ft.forEach(i),We=d(l),v=r(l,"DIV",{class:!0});var E=o(v);je=a(E,`The program functions as an interactive session interpreter,
            so it will keep taking lines of user input from the terminal until the user enters "run"
            `),Ce=r(E,"BR",{}),Je=r(E,"BR",{}),Pe=a(E,`
            For every line of user input the program will iterate through all the characters 
            and filter out any that aren't one of the 8 operators
            `),Ue=r(E,"BR",{}),Ye=r(E,"BR",{}),Ke=d(E),k=r(E,"IMG",{style:!0,src:!0,alt:!0}),E.forEach(i),Qe=d(l),$=r(l,"DIV",{class:!0});var Tt=o($);Xe=a(Tt,"Reading user input"),Tt.forEach(i),Ze=d(l),y=r(l,"DIV",{class:!0});var U=o(y);et=a(U,`I made the design decision of having all user input entered before the program is interpreted. 
            `),tt=r(U,"BR",{}),rt=r(U,"BR",{}),nt=a(U,`
            This meant that all input could be entered quickly on a single line`),U.forEach(i),at=d(l),x=r(l,"DIV",{class:!0});var Vt=o(x);it=a(Vt,"Interpreting the program"),Vt.forEach(i),ot=d(l),B=r(l,"DIV",{class:!0});var Y=o(B);st=a(Y,`The program uses a while loop to keep running through the characters in the program 
            until the end has been reached
            `),lt=r(Y,"BR",{}),ht=r(Y,"BR",{}),dt=a(Y,`
            Inside the while loop a match statement is used to match the current 
            operator to the current code to run for that operator`),Y.forEach(i),l.forEach(i),X.forEach(i),this.h()},h(){m(L,"class","title"),m(F,"class","header"),m(c,"class","no_dot"),m(b,"class","text"),m(T,"class","header"),m(g,"class","text"),m(V,"class","sub_header"),Mt(k,"width","25rem"),Nt(k.src,ut="/images/brainfuck/iterator.png")||m(k,"src",ut),m(k,"alt","Rust code showing iterator I used"),m(v,"class","text"),m($,"class","sub_header"),m(y,"class","text"),m(x,"class","sub_header"),m(B,"class","text"),m(s,"class","content")},m(u,z){ct(u,f,z),e(f,q),e(q,Z),ct(u,K,z),ct(u,w,z),Ot(R,w,null),e(w,ee),e(w,s),e(s,L),e(L,te),e(s,re),e(s,F),e(F,ne),e(s,ae),e(s,b),e(b,ie),e(b,oe),e(b,se),e(b,le),e(b,c),e(c,H),e(H,he),e(c,de),e(c,M),e(M,ce),e(c,pe),e(c,N),e(N,ue),e(c,me),e(c,O),e(O,ge),e(c,fe),e(c,S),e(S,ve),e(c,be),e(c,G),e(G,_e),e(c,Ie),e(c,W),e(W,ye),e(c,Be),e(c,j),e(j,Ee),e(b,we),e(s,Re),e(s,T),e(T,ke),e(s,De),e(s,g),e(g,Le),e(g,Fe),e(g,Te),e(g,Ve),e(g,$e),e(g,xe),e(g,ze),e(g,I),e(I,C),e(C,Ae),e(I,qe),e(I,J),e(J,He),e(I,Me),e(I,P),e(P,Ne),e(g,Oe),e(s,Se),e(s,V),e(V,Ge),e(s,We),e(s,v),e(v,je),e(v,Ce),e(v,Je),e(v,Pe),e(v,Ue),e(v,Ye),e(v,Ke),e(v,k),e(s,Qe),e(s,$),e($,Xe),e(s,Ze),e(s,y),e(y,et),e(y,tt),e(y,rt),e(y,nt),e(s,at),e(s,x),e(x,it),e(s,ot),e(s,B),e(B,st),e(B,lt),e(B,ht),e(B,dt),Q=!0},p:St,i(u){Q||(Gt(R.$$.fragment,u),Q=!0)},o(u){Wt(R.$$.fragment,u),Q=!1},d(u){u&&i(f),u&&i(K),u&&i(w),jt(R)}}}function Ut(pt){let f;return Ct(()=>{f=$t(window),document.getElementsByTagName("html")[0].style.fontSize=`${f}vw`,window.addEventListener("resize",()=>{f=$t(window),document.getElementsByTagName("html")[0].style.fontSize=`${f}vw`})}),[]}class Xt extends xt{constructor(f){super(),zt(this,f,Ut,Pt,At,{})}}export{Xt as default};
