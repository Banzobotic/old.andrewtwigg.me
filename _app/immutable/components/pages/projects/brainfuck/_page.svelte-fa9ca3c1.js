import{S as xt,i as zt,s as qt,k as t,q as n,a as h,w as At,l as r,m as o,r as a,h as i,c as d,x as Mt,n as m,p as Nt,I as Ot,b as ct,G as e,y as St,B as Ht,f as Gt,t as Wt,z as jt,o as Ct}from"../../../../chunks/index-13fba489.js";import{N as Pt}from"../../../../chunks/Navbar-e41baf31.js";import{c as $t}from"../../../../chunks/units-a223cfbb.js";function Ut(pt){let f,A,Z,K,E,R,ee,s,L,te,re,F,ne,ae,b,ie,oe,se,le,c,M,he,de,N,ce,pe,O,ue,me,S,ge,fe,H,ve,be,G,_e,Ie,W,ye,Be,j,we,Ee,Re,T,ke,De,g,Le,Fe,Te,Ve,$e,xe,ze,I,C,qe,Ae,P,Me,Ne,U,Oe,Se,He,V,Ge,We,v,je,Ce,Pe,Ue,Ye,Je,Ke,k,ut,Qe,$,Xe,Ze,y,et,tt,rt,nt,at,x,it,ot,B,st,lt,ht,dt,Q;return R=new Pt({}),{c(){f=t("head"),A=t("title"),Z=n("Home"),K=h(),E=t("body"),At(R.$$.fragment),ee=h(),s=t("div"),L=t("div"),te=n("Brainf**k Interpreter"),re=h(),F=t("div"),ne=n("What is Brainf**k?"),ae=h(),b=t("div"),ie=n(`Brainf**k (BF) is an esolang centred around a single array of bytes
            `),oe=t("br"),se=t("br"),le=n(`
            There are only 8 operators in BF:
            `),c=t("ul"),M=t("li"),he=n("> Increment the pointer position"),de=h(),N=t("li"),ce=n("< Deincrement the pointer position"),pe=h(),O=t("li"),ue=n("+ Increment the byte at the pointer"),me=h(),S=t("li"),ge=n("- Deincrement the byte at the pointer"),fe=h(),H=t("li"),ve=n(". Output the byte at the data pointer"),be=h(),G=t("li"),_e=n(", Accept one byte of input, storing it in the byte at the pointer"),Ie=h(),W=t("li"),ye=n("[ If the byte at the pointer is zero, goto the corresponding ] operator"),Be=h(),j=t("li"),we=n("] If the byte at the pointer is nonzero, goto the corresponding [ operator"),Ee=n(`
            Despite only having these 8 operators BF is (with an infinitely large array) turing complete`),Re=h(),T=t("div"),ke=n("Implementing Brainf**k"),De=h(),g=t("div"),Le=n(`Around the time that I found out about BF I was also learning the programming language Rust
            `),Fe=t("br"),Te=t("br"),Ve=n(`
            I decided to write my BF interpreter in Rust as it provided a great opportunity to start
            getting to grips with Rust's match statements and iterators
            `),$e=t("br"),xe=t("br"),ze=n(`
            My brainf**k interpreter has 3 main parts:
            `),I=t("ol"),C=t("li"),qe=n("Read and parse the program"),Ae=h(),P=t("li"),Me=n("Read input"),Ne=h(),U=t("li"),Oe=n("Interpret the program"),Se=n(`
            Lets break down how I solved each of these presentations`),He=h(),V=t("div"),Ge=n("Reading and parsing the program"),We=h(),v=t("div"),je=n(`The program functions as an interactive session interpreter,
            so it will keep taking lines of user input from the terminal until the user enters "run"
            `),Ce=t("br"),Pe=t("br"),Ue=n(`
            For every line of user input the program will iterate through all the characters 
            and filter out any that aren't one of the 8 operators
            `),Ye=t("br"),Je=t("br"),Ke=h(),k=t("img"),Qe=h(),$=t("div"),Xe=n("Reading user input"),Ze=h(),y=t("div"),et=n(`I made the design decision of having all user input entered before the program is interpreted. 
            `),tt=t("br"),rt=t("br"),nt=n(`
            This meant that all input could be entered quickly on a single line`),at=h(),x=t("div"),it=n("Interpreting the program"),ot=h(),B=t("div"),st=n(`The program uses a while loop to keep running through the characters in the program 
            until the end has been reached
            `),lt=t("br"),ht=t("br"),dt=n(`
            Inside the while loop a match statement is used to match the current 
            operator to the current code to run for that operator`),this.h()},l(u){f=r(u,"HEAD",{});var z=o(f);A=r(z,"TITLE",{});var mt=o(A);Z=a(mt,"Home"),mt.forEach(i),z.forEach(i),K=d(u),E=r(u,"BODY",{});var X=o(E);Mt(R.$$.fragment,X),ee=d(X),s=r(X,"DIV",{class:!0});var l=o(s);L=r(l,"DIV",{class:!0});var gt=o(L);te=a(gt,"Brainf**k Interpreter"),gt.forEach(i),re=d(l),F=r(l,"DIV",{class:!0});var ft=o(F);ne=a(ft,"What is Brainf**k?"),ft.forEach(i),ae=d(l),b=r(l,"DIV",{class:!0});var D=o(b);ie=a(D,`Brainf**k (BF) is an esolang centred around a single array of bytes
            `),oe=r(D,"BR",{}),se=r(D,"BR",{}),le=a(D,`
            There are only 8 operators in BF:
            `),c=r(D,"UL",{class:!0});var p=o(c);M=r(p,"LI",{});var vt=o(M);he=a(vt,"> Increment the pointer position"),vt.forEach(i),de=d(p),N=r(p,"LI",{});var bt=o(N);ce=a(bt,"< Deincrement the pointer position"),bt.forEach(i),pe=d(p),O=r(p,"LI",{});var _t=o(O);ue=a(_t,"+ Increment the byte at the pointer"),_t.forEach(i),me=d(p),S=r(p,"LI",{});var It=o(S);ge=a(It,"- Deincrement the byte at the pointer"),It.forEach(i),fe=d(p),H=r(p,"LI",{});var yt=o(H);ve=a(yt,". Output the byte at the data pointer"),yt.forEach(i),be=d(p),G=r(p,"LI",{});var Bt=o(G);_e=a(Bt,", Accept one byte of input, storing it in the byte at the pointer"),Bt.forEach(i),Ie=d(p),W=r(p,"LI",{});var wt=o(W);ye=a(wt,"[ If the byte at the pointer is zero, goto the corresponding ] operator"),wt.forEach(i),Be=d(p),j=r(p,"LI",{});var Et=o(j);we=a(Et,"] If the byte at the pointer is nonzero, goto the corresponding [ operator"),Et.forEach(i),p.forEach(i),Ee=a(D,`
            Despite only having these 8 operators BF is (with an infinitely large array) turing complete`),D.forEach(i),Re=d(l),T=r(l,"DIV",{class:!0});var Rt=o(T);ke=a(Rt,"Implementing Brainf**k"),Rt.forEach(i),De=d(l),g=r(l,"DIV",{class:!0});var _=o(g);Le=a(_,`Around the time that I found out about BF I was also learning the programming language Rust
            `),Fe=r(_,"BR",{}),Te=r(_,"BR",{}),Ve=a(_,`
            I decided to write my BF interpreter in Rust as it provided a great opportunity to start
            getting to grips with Rust's match statements and iterators
            `),$e=r(_,"BR",{}),xe=r(_,"BR",{}),ze=a(_,`
            My brainf**k interpreter has 3 main parts:
            `),I=r(_,"OL",{});var q=o(I);C=r(q,"LI",{});var kt=o(C);qe=a(kt,"Read and parse the program"),kt.forEach(i),Ae=d(q),P=r(q,"LI",{});var Dt=o(P);Me=a(Dt,"Read input"),Dt.forEach(i),Ne=d(q),U=r(q,"LI",{});var Lt=o(U);Oe=a(Lt,"Interpret the program"),Lt.forEach(i),q.forEach(i),Se=a(_,`
            Lets break down how I solved each of these presentations`),_.forEach(i),He=d(l),V=r(l,"DIV",{class:!0});var Ft=o(V);Ge=a(Ft,"Reading and parsing the program"),Ft.forEach(i),We=d(l),v=r(l,"DIV",{class:!0});var w=o(v);je=a(w,`The program functions as an interactive session interpreter,
            so it will keep taking lines of user input from the terminal until the user enters "run"
            `),Ce=r(w,"BR",{}),Pe=r(w,"BR",{}),Ue=a(w,`
            For every line of user input the program will iterate through all the characters 
            and filter out any that aren't one of the 8 operators
            `),Ye=r(w,"BR",{}),Je=r(w,"BR",{}),Ke=d(w),k=r(w,"IMG",{style:!0,src:!0,alt:!0}),w.forEach(i),Qe=d(l),$=r(l,"DIV",{class:!0});var Tt=o($);Xe=a(Tt,"Reading user input"),Tt.forEach(i),Ze=d(l),y=r(l,"DIV",{class:!0});var Y=o(y);et=a(Y,`I made the design decision of having all user input entered before the program is interpreted. 
            `),tt=r(Y,"BR",{}),rt=r(Y,"BR",{}),nt=a(Y,`
            This meant that all input could be entered quickly on a single line`),Y.forEach(i),at=d(l),x=r(l,"DIV",{class:!0});var Vt=o(x);it=a(Vt,"Interpreting the program"),Vt.forEach(i),ot=d(l),B=r(l,"DIV",{class:!0});var J=o(B);st=a(J,`The program uses a while loop to keep running through the characters in the program 
            until the end has been reached
            `),lt=r(J,"BR",{}),ht=r(J,"BR",{}),dt=a(J,`
            Inside the while loop a match statement is used to match the current 
            operator to the current code to run for that operator`),J.forEach(i),l.forEach(i),X.forEach(i),this.h()},h(){m(L,"class","title"),m(F,"class","header"),m(c,"class","no_dot"),m(b,"class","text"),m(T,"class","header"),m(g,"class","text"),m(V,"class","sub_header"),Nt(k,"width","25rem"),Ot(k.src,ut="/images/brainfuck/iterator.png")||m(k,"src",ut),m(k,"alt","Rust code showing iterator I used"),m(v,"class","text"),m($,"class","sub_header"),m(y,"class","text"),m(x,"class","sub_header"),m(B,"class","text"),m(s,"class","content")},m(u,z){ct(u,f,z),e(f,A),e(A,Z),ct(u,K,z),ct(u,E,z),St(R,E,null),e(E,ee),e(E,s),e(s,L),e(L,te),e(s,re),e(s,F),e(F,ne),e(s,ae),e(s,b),e(b,ie),e(b,oe),e(b,se),e(b,le),e(b,c),e(c,M),e(M,he),e(c,de),e(c,N),e(N,ce),e(c,pe),e(c,O),e(O,ue),e(c,me),e(c,S),e(S,ge),e(c,fe),e(c,H),e(H,ve),e(c,be),e(c,G),e(G,_e),e(c,Ie),e(c,W),e(W,ye),e(c,Be),e(c,j),e(j,we),e(b,Ee),e(s,Re),e(s,T),e(T,ke),e(s,De),e(s,g),e(g,Le),e(g,Fe),e(g,Te),e(g,Ve),e(g,$e),e(g,xe),e(g,ze),e(g,I),e(I,C),e(C,qe),e(I,Ae),e(I,P),e(P,Me),e(I,Ne),e(I,U),e(U,Oe),e(g,Se),e(s,He),e(s,V),e(V,Ge),e(s,We),e(s,v),e(v,je),e(v,Ce),e(v,Pe),e(v,Ue),e(v,Ye),e(v,Je),e(v,Ke),e(v,k),e(s,Qe),e(s,$),e($,Xe),e(s,Ze),e(s,y),e(y,et),e(y,tt),e(y,rt),e(y,nt),e(s,at),e(s,x),e(x,it),e(s,ot),e(s,B),e(B,st),e(B,lt),e(B,ht),e(B,dt),Q=!0},p:Ht,i(u){Q||(Gt(R.$$.fragment,u),Q=!0)},o(u){Wt(R.$$.fragment,u),Q=!1},d(u){u&&i(f),u&&i(K),u&&i(E),jt(R)}}}function Yt(pt){let f;return Ct(()=>{f=$t(window),document.getElementsByTagName("html")[0].style.fontSize=`${f}vw`,window.addEventListener("resize",()=>{f=$t(window),document.getElementsByTagName("html")[0].style.fontSize=`${f}vw`})}),[]}class Xt extends xt{constructor(f){super(),zt(this,f,Yt,Ut,qt,{})}}export{Xt as default};
