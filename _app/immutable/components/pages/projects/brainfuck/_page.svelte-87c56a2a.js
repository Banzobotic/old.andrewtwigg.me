import{S as Tt,i as $t,s as qt,k as t,q as n,a as h,w as zt,l as r,m as o,r as a,h as i,c as d,x as At,n as g,p as Ot,I as Ht,b as pt,G as e,y as Mt,B as Gt,f as Nt,t as St,z as Wt}from"../../../../chunks/index-13fba489.js";import{N as Ct}from"../../../../chunks/Navbar-d8336603.js";function Pt(xt){let E,A,Z,K,R,w,ee,s,L,te,re,F,ne,ae,v,ie,oe,se,le,p,O,he,de,H,pe,ce,M,ue,ge,G,me,fe,N,ve,be,S,_e,Ie,W,ye,Be,C,Ee,Re,we,V,ke,De,m,Le,Fe,Ve,xe,Te,$e,qe,_,P,ze,Ae,U,Oe,He,Y,Me,Ge,Ne,x,Se,We,f,Ce,Pe,Ue,Ye,je,Je,Ke,k,ct,Qe,T,Xe,Ze,I,et,tt,rt,nt,at,$,it,ot,y,st,lt,ht,dt,Q;return w=new Ct({}),{c(){E=t("head"),A=t("title"),Z=n("Home"),K=h(),R=t("body"),zt(w.$$.fragment),ee=h(),s=t("div"),L=t("div"),te=n("Brainf**k Interpreter"),re=h(),F=t("div"),ne=n("What is Brainf**k?"),ae=h(),v=t("div"),ie=n(`Brainf**k (BF) is an esolang centred around a single array of bytes
            `),oe=t("br"),se=t("br"),le=n(`
            There are only 8 operators in BF:
            `),p=t("ul"),O=t("li"),he=n("> Increment the pointer position"),de=h(),H=t("li"),pe=n("< Deincrement the pointer position"),ce=h(),M=t("li"),ue=n("+ Increment the byte at the pointer"),ge=h(),G=t("li"),me=n("- Deincrement the byte at the pointer"),fe=h(),N=t("li"),ve=n(". Output the byte at the data pointer"),be=h(),S=t("li"),_e=n(", Accept one byte of input, storing it in the byte at the pointer"),Ie=h(),W=t("li"),ye=n("[ If the byte at the pointer is zero, goto the corresponding ] operator"),Be=h(),C=t("li"),Ee=n("] If the byte at the pointer is nonzero, goto the corresponding [ operator"),Re=n(`
            Despite only having these 8 operators BF is (with an infinitely large array) turing complete`),we=h(),V=t("div"),ke=n("Implementing Brainf**k"),De=h(),m=t("div"),Le=n(`Around the time that I found out about BF I was also learning the programming language Rust
            `),Fe=t("br"),Ve=t("br"),xe=n(`
            I decided to write my BF interpreter in Rust as it provided a great opportunity to start
            getting to grips with Rust's match statements and iterators
            `),Te=t("br"),$e=t("br"),qe=n(`
            My brainf**k interpreter has 3 main parts:
            `),_=t("ol"),P=t("li"),ze=n("Read and parse the program"),Ae=h(),U=t("li"),Oe=n("Read input"),He=h(),Y=t("li"),Me=n("Interpret the program"),Ge=n(`
            Lets break down how I solved each of these presentations`),Ne=h(),x=t("div"),Se=n("Reading and parsing the program"),We=h(),f=t("div"),Ce=n(`The program functions as an interactive session interpreter,
            so it will keep taking lines of user input from the terminal until the user enters "run"
            `),Pe=t("br"),Ue=t("br"),Ye=n(`
            For every line of user input the program will iterate through all the characters 
            and filter out any that aren't one of the 8 operators
            `),je=t("br"),Je=t("br"),Ke=h(),k=t("img"),Qe=h(),T=t("div"),Xe=n("Reading user input"),Ze=h(),I=t("div"),et=n(`I made the design decision of having all user input entered before the program is interpreted. 
            `),tt=t("br"),rt=t("br"),nt=n(`
            This meant that all input could be entered quickly on a single line`),at=h(),$=t("div"),it=n("Interpreting the program"),ot=h(),y=t("div"),st=n(`The program uses a while loop to keep running through the characters in the program 
            until the end has been reached
            `),lt=t("br"),ht=t("br"),dt=n(`
            Inside the while loop a match statement is used to match the current 
            operator to the current code to run for that operator`),this.h()},l(u){E=r(u,"HEAD",{});var q=o(E);A=r(q,"TITLE",{});var ut=o(A);Z=a(ut,"Home"),ut.forEach(i),q.forEach(i),K=d(u),R=r(u,"BODY",{});var X=o(R);At(w.$$.fragment,X),ee=d(X),s=r(X,"DIV",{class:!0});var l=o(s);L=r(l,"DIV",{class:!0});var gt=o(L);te=a(gt,"Brainf**k Interpreter"),gt.forEach(i),re=d(l),F=r(l,"DIV",{class:!0});var mt=o(F);ne=a(mt,"What is Brainf**k?"),mt.forEach(i),ae=d(l),v=r(l,"DIV",{class:!0});var D=o(v);ie=a(D,`Brainf**k (BF) is an esolang centred around a single array of bytes
            `),oe=r(D,"BR",{}),se=r(D,"BR",{}),le=a(D,`
            There are only 8 operators in BF:
            `),p=r(D,"UL",{class:!0});var c=o(p);O=r(c,"LI",{});var ft=o(O);he=a(ft,"> Increment the pointer position"),ft.forEach(i),de=d(c),H=r(c,"LI",{});var vt=o(H);pe=a(vt,"< Deincrement the pointer position"),vt.forEach(i),ce=d(c),M=r(c,"LI",{});var bt=o(M);ue=a(bt,"+ Increment the byte at the pointer"),bt.forEach(i),ge=d(c),G=r(c,"LI",{});var _t=o(G);me=a(_t,"- Deincrement the byte at the pointer"),_t.forEach(i),fe=d(c),N=r(c,"LI",{});var It=o(N);ve=a(It,". Output the byte at the data pointer"),It.forEach(i),be=d(c),S=r(c,"LI",{});var yt=o(S);_e=a(yt,", Accept one byte of input, storing it in the byte at the pointer"),yt.forEach(i),Ie=d(c),W=r(c,"LI",{});var Bt=o(W);ye=a(Bt,"[ If the byte at the pointer is zero, goto the corresponding ] operator"),Bt.forEach(i),Be=d(c),C=r(c,"LI",{});var Et=o(C);Ee=a(Et,"] If the byte at the pointer is nonzero, goto the corresponding [ operator"),Et.forEach(i),c.forEach(i),Re=a(D,`
            Despite only having these 8 operators BF is (with an infinitely large array) turing complete`),D.forEach(i),we=d(l),V=r(l,"DIV",{class:!0});var Rt=o(V);ke=a(Rt,"Implementing Brainf**k"),Rt.forEach(i),De=d(l),m=r(l,"DIV",{class:!0});var b=o(m);Le=a(b,`Around the time that I found out about BF I was also learning the programming language Rust
            `),Fe=r(b,"BR",{}),Ve=r(b,"BR",{}),xe=a(b,`
            I decided to write my BF interpreter in Rust as it provided a great opportunity to start
            getting to grips with Rust's match statements and iterators
            `),Te=r(b,"BR",{}),$e=r(b,"BR",{}),qe=a(b,`
            My brainf**k interpreter has 3 main parts:
            `),_=r(b,"OL",{});var z=o(_);P=r(z,"LI",{});var wt=o(P);ze=a(wt,"Read and parse the program"),wt.forEach(i),Ae=d(z),U=r(z,"LI",{});var kt=o(U);Oe=a(kt,"Read input"),kt.forEach(i),He=d(z),Y=r(z,"LI",{});var Dt=o(Y);Me=a(Dt,"Interpret the program"),Dt.forEach(i),z.forEach(i),Ge=a(b,`
            Lets break down how I solved each of these presentations`),b.forEach(i),Ne=d(l),x=r(l,"DIV",{class:!0});var Lt=o(x);Se=a(Lt,"Reading and parsing the program"),Lt.forEach(i),We=d(l),f=r(l,"DIV",{class:!0});var B=o(f);Ce=a(B,`The program functions as an interactive session interpreter,
            so it will keep taking lines of user input from the terminal until the user enters "run"
            `),Pe=r(B,"BR",{}),Ue=r(B,"BR",{}),Ye=a(B,`
            For every line of user input the program will iterate through all the characters 
            and filter out any that aren't one of the 8 operators
            `),je=r(B,"BR",{}),Je=r(B,"BR",{}),Ke=d(B),k=r(B,"IMG",{style:!0,src:!0,alt:!0}),B.forEach(i),Qe=d(l),T=r(l,"DIV",{class:!0});var Ft=o(T);Xe=a(Ft,"Reading user input"),Ft.forEach(i),Ze=d(l),I=r(l,"DIV",{class:!0});var j=o(I);et=a(j,`I made the design decision of having all user input entered before the program is interpreted. 
            `),tt=r(j,"BR",{}),rt=r(j,"BR",{}),nt=a(j,`
            This meant that all input could be entered quickly on a single line`),j.forEach(i),at=d(l),$=r(l,"DIV",{class:!0});var Vt=o($);it=a(Vt,"Interpreting the program"),Vt.forEach(i),ot=d(l),y=r(l,"DIV",{class:!0});var J=o(y);st=a(J,`The program uses a while loop to keep running through the characters in the program 
            until the end has been reached
            `),lt=r(J,"BR",{}),ht=r(J,"BR",{}),dt=a(J,`
            Inside the while loop a match statement is used to match the current 
            operator to the current code to run for that operator`),J.forEach(i),l.forEach(i),X.forEach(i),this.h()},h(){g(L,"class","title"),g(F,"class","header"),g(p,"class","no_dot"),g(v,"class","text"),g(V,"class","header"),g(m,"class","text"),g(x,"class","sub_header"),Ot(k,"width","25vw"),Ht(k.src,ct="/images/brainfuck/iterator.png")||g(k,"src",ct),g(k,"alt","Rust code showing iterator I used"),g(f,"class","text"),g(T,"class","sub_header"),g(I,"class","text"),g($,"class","sub_header"),g(y,"class","text"),g(s,"class","content")},m(u,q){pt(u,E,q),e(E,A),e(A,Z),pt(u,K,q),pt(u,R,q),Mt(w,R,null),e(R,ee),e(R,s),e(s,L),e(L,te),e(s,re),e(s,F),e(F,ne),e(s,ae),e(s,v),e(v,ie),e(v,oe),e(v,se),e(v,le),e(v,p),e(p,O),e(O,he),e(p,de),e(p,H),e(H,pe),e(p,ce),e(p,M),e(M,ue),e(p,ge),e(p,G),e(G,me),e(p,fe),e(p,N),e(N,ve),e(p,be),e(p,S),e(S,_e),e(p,Ie),e(p,W),e(W,ye),e(p,Be),e(p,C),e(C,Ee),e(v,Re),e(s,we),e(s,V),e(V,ke),e(s,De),e(s,m),e(m,Le),e(m,Fe),e(m,Ve),e(m,xe),e(m,Te),e(m,$e),e(m,qe),e(m,_),e(_,P),e(P,ze),e(_,Ae),e(_,U),e(U,Oe),e(_,He),e(_,Y),e(Y,Me),e(m,Ge),e(s,Ne),e(s,x),e(x,Se),e(s,We),e(s,f),e(f,Ce),e(f,Pe),e(f,Ue),e(f,Ye),e(f,je),e(f,Je),e(f,Ke),e(f,k),e(s,Qe),e(s,T),e(T,Xe),e(s,Ze),e(s,I),e(I,et),e(I,tt),e(I,rt),e(I,nt),e(s,at),e(s,$),e($,it),e(s,ot),e(s,y),e(y,st),e(y,lt),e(y,ht),e(y,dt),Q=!0},p:Gt,i(u){Q||(Nt(w.$$.fragment,u),Q=!0)},o(u){St(w.$$.fragment,u),Q=!1},d(u){u&&i(E),u&&i(K),u&&i(R),Wt(w)}}}class jt extends Tt{constructor(E){super(),$t(this,E,null,Pt,qt,{})}}export{jt as default};
