import{S as qt,i as zt,s as At,k as r,q as l,a as h,w as Ot,l as a,m as i,r as n,h as s,c as d,x as Ht,n as t,p as Mt,I as Gt,b as ut,G as e,y as Nt,B as St,f as Wt,t as Ct,z as Pt}from"../../../../chunks/index-13fba489.js";import{N as Ut}from"../../../../chunks/Navbar-d8336603.js";function Yt($t){let I,D,me,Q,x,w,ve,L,o,V,be,ge,F,fe,_e,g,Ie,X,Z,xe,u,T,ye,Be,$,Ee,Re,q,we,ke,z,De,Le,A,Ve,Fe,O,Te,$e,H,qe,ze,M,Ae,Oe,He,G,Me,Ge,v,Ne,ee,te,Se,re,ae,We,f,N,Ce,Pe,S,Ue,Ye,W,je,Je,Ke,C,Qe,Xe,b,Ze,se,le,et,ne,ie,tt,R,pt,rt,P,at,st,y,lt,oe,ce,nt,it,U,ot,ct,B,ht,he,de,dt,ue;return w=new Ut({}),{c(){I=r("head"),D=r("title"),me=l("Home"),Q=h(),x=r("body"),Ot(w.$$.fragment),ve=h(),L=r("div"),o=r("div"),V=r("div"),be=l("Brainf**k Interpreter"),ge=h(),F=r("div"),fe=l("What is Brainf**k?"),_e=h(),g=r("div"),Ie=l(`Brainf**k (BF) is an esolang centred around a single array of bytes
                `),X=r("br"),Z=r("br"),xe=l(`
                There are only 8 operators in BF:
                `),u=r("ul"),T=r("li"),ye=l("> Increment the pointer position"),Be=h(),$=r("li"),Ee=l("< Deincrement the pointer position"),Re=h(),q=r("li"),we=l("+ Increment the byte at the pointer"),ke=h(),z=r("li"),De=l("- Deincrement the byte at the pointer"),Le=h(),A=r("li"),Ve=l(". Output the byte at the data pointer"),Fe=h(),O=r("li"),Te=l(", Accept one byte of input, storing it in the byte at the pointer"),$e=h(),H=r("li"),qe=l("[ If the byte at the pointer is zero, goto the corresponding ] operator"),ze=h(),M=r("li"),Ae=l("] If the byte at the pointer is nonzero, goto the corresponding [ operator"),Oe=l(`
                Despite only having these 8 operators BF is (with an infinitely large array) turing complete`),He=h(),G=r("div"),Me=l("Implementing Brainf**k"),Ge=h(),v=r("div"),Ne=l(`Around the time that I found out about BF I was also learning the programming language Rust
                `),ee=r("br"),te=r("br"),Se=l(`
                I decided to write my BF interpreter in Rust as it provided a great opportunity to start
                getting to grips with Rust's match statements and iterators
                `),re=r("br"),ae=r("br"),We=l(`
                My brainf**k interpreter has 3 main parts:
                `),f=r("ol"),N=r("li"),Ce=l("Read and parse the program"),Pe=h(),S=r("li"),Ue=l("Read input"),Ye=h(),W=r("li"),je=l("Interpret the program"),Je=l(`
                Lets break down how I solved each of these presentations`),Ke=h(),C=r("div"),Qe=l("Reading and parsing the program"),Xe=h(),b=r("div"),Ze=l(`The program functions as an interactive session interpreter,
                so it will keep taking lines of user input from the terminal until the user enters "run"
                `),se=r("br"),le=r("br"),et=l(`
                For every line of user input the program will iterate through all the characters 
                and filter out any that aren't one of the 8 operators
                `),ne=r("br"),ie=r("br"),tt=h(),R=r("img"),rt=h(),P=r("div"),at=l("Reading user input"),st=h(),y=r("div"),lt=l(`I made the design decision of having all user input entered before the program is interpreted. 
                `),oe=r("br"),ce=r("br"),nt=l(`
                This meant that all input could be entered quickly on a single line`),it=h(),U=r("div"),ot=l("Interpreting the program"),ct=h(),B=r("div"),ht=l(`The program uses a while loop to keep running through the characters in the program 
                until the end has been reached
                `),he=r("br"),de=r("br"),dt=l(`
                Inside the while loop a match statement is used to match the current 
                operator to the current code to run for that operator`),this.h()},l(m){I=a(m,"HEAD",{class:!0});var Y=i(I);D=a(Y,"TITLE",{class:!0});var mt=i(D);me=n(mt,"Home"),mt.forEach(s),Y.forEach(s),Q=d(m),x=a(m,"BODY",{class:!0});var pe=i(x);Ht(w.$$.fragment,pe),ve=d(pe),L=a(pe,"DIV",{class:!0});var vt=i(L);o=a(vt,"DIV",{class:!0});var c=i(o);V=a(c,"DIV",{class:!0});var bt=i(V);be=n(bt,"Brainf**k Interpreter"),bt.forEach(s),ge=d(c),F=a(c,"DIV",{class:!0});var gt=i(F);fe=n(gt,"What is Brainf**k?"),gt.forEach(s),_e=d(c),g=a(c,"DIV",{class:!0});var k=i(g);Ie=n(k,`Brainf**k (BF) is an esolang centred around a single array of bytes
                `),X=a(k,"BR",{class:!0}),Z=a(k,"BR",{class:!0}),xe=n(k,`
                There are only 8 operators in BF:
                `),u=a(k,"UL",{class:!0});var p=i(u);T=a(p,"LI",{class:!0});var ft=i(T);ye=n(ft,"> Increment the pointer position"),ft.forEach(s),Be=d(p),$=a(p,"LI",{class:!0});var _t=i($);Ee=n(_t,"< Deincrement the pointer position"),_t.forEach(s),Re=d(p),q=a(p,"LI",{class:!0});var It=i(q);we=n(It,"+ Increment the byte at the pointer"),It.forEach(s),ke=d(p),z=a(p,"LI",{class:!0});var xt=i(z);De=n(xt,"- Deincrement the byte at the pointer"),xt.forEach(s),Le=d(p),A=a(p,"LI",{class:!0});var yt=i(A);Ve=n(yt,". Output the byte at the data pointer"),yt.forEach(s),Fe=d(p),O=a(p,"LI",{class:!0});var Bt=i(O);Te=n(Bt,", Accept one byte of input, storing it in the byte at the pointer"),Bt.forEach(s),$e=d(p),H=a(p,"LI",{class:!0});var Et=i(H);qe=n(Et,"[ If the byte at the pointer is zero, goto the corresponding ] operator"),Et.forEach(s),ze=d(p),M=a(p,"LI",{class:!0});var Rt=i(M);Ae=n(Rt,"] If the byte at the pointer is nonzero, goto the corresponding [ operator"),Rt.forEach(s),p.forEach(s),Oe=n(k,`
                Despite only having these 8 operators BF is (with an infinitely large array) turing complete`),k.forEach(s),He=d(c),G=a(c,"DIV",{class:!0});var wt=i(G);Me=n(wt,"Implementing Brainf**k"),wt.forEach(s),Ge=d(c),v=a(c,"DIV",{class:!0});var _=i(v);Ne=n(_,`Around the time that I found out about BF I was also learning the programming language Rust
                `),ee=a(_,"BR",{class:!0}),te=a(_,"BR",{class:!0}),Se=n(_,`
                I decided to write my BF interpreter in Rust as it provided a great opportunity to start
                getting to grips with Rust's match statements and iterators
                `),re=a(_,"BR",{class:!0}),ae=a(_,"BR",{class:!0}),We=n(_,`
                My brainf**k interpreter has 3 main parts:
                `),f=a(_,"OL",{class:!0});var j=i(f);N=a(j,"LI",{class:!0});var kt=i(N);Ce=n(kt,"Read and parse the program"),kt.forEach(s),Pe=d(j),S=a(j,"LI",{class:!0});var Dt=i(S);Ue=n(Dt,"Read input"),Dt.forEach(s),Ye=d(j),W=a(j,"LI",{class:!0});var Lt=i(W);je=n(Lt,"Interpret the program"),Lt.forEach(s),j.forEach(s),Je=n(_,`
                Lets break down how I solved each of these presentations`),_.forEach(s),Ke=d(c),C=a(c,"DIV",{class:!0});var Vt=i(C);Qe=n(Vt,"Reading and parsing the program"),Vt.forEach(s),Xe=d(c),b=a(c,"DIV",{class:!0});var E=i(b);Ze=n(E,`The program functions as an interactive session interpreter,
                so it will keep taking lines of user input from the terminal until the user enters "run"
                `),se=a(E,"BR",{class:!0}),le=a(E,"BR",{class:!0}),et=n(E,`
                For every line of user input the program will iterate through all the characters 
                and filter out any that aren't one of the 8 operators
                `),ne=a(E,"BR",{class:!0}),ie=a(E,"BR",{class:!0}),tt=d(E),R=a(E,"IMG",{style:!0,src:!0,alt:!0,class:!0}),E.forEach(s),rt=d(c),P=a(c,"DIV",{class:!0});var Ft=i(P);at=n(Ft,"Reading user input"),Ft.forEach(s),st=d(c),y=a(c,"DIV",{class:!0});var J=i(y);lt=n(J,`I made the design decision of having all user input entered before the program is interpreted. 
                `),oe=a(J,"BR",{class:!0}),ce=a(J,"BR",{class:!0}),nt=n(J,`
                This meant that all input could be entered quickly on a single line`),J.forEach(s),it=d(c),U=a(c,"DIV",{class:!0});var Tt=i(U);ot=n(Tt,"Interpreting the program"),Tt.forEach(s),ct=d(c),B=a(c,"DIV",{class:!0});var K=i(B);ht=n(K,`The program uses a while loop to keep running through the characters in the program 
                until the end has been reached
                `),he=a(K,"BR",{class:!0}),de=a(K,"BR",{class:!0}),dt=n(K,`
                Inside the while loop a match statement is used to match the current 
                operator to the current code to run for that operator`),K.forEach(s),c.forEach(s),vt.forEach(s),pe.forEach(s),this.h()},h(){t(D,"class","svelte-1bxmatr"),t(I,"class","svelte-1bxmatr"),t(V,"class","title svelte-1bxmatr"),t(F,"class","header svelte-1bxmatr"),t(X,"class","svelte-1bxmatr"),t(Z,"class","svelte-1bxmatr"),t(T,"class","svelte-1bxmatr"),t($,"class","svelte-1bxmatr"),t(q,"class","svelte-1bxmatr"),t(z,"class","svelte-1bxmatr"),t(A,"class","svelte-1bxmatr"),t(O,"class","svelte-1bxmatr"),t(H,"class","svelte-1bxmatr"),t(M,"class","svelte-1bxmatr"),t(u,"class","no_dot svelte-1bxmatr"),t(g,"class","text svelte-1bxmatr"),t(G,"class","header svelte-1bxmatr"),t(ee,"class","svelte-1bxmatr"),t(te,"class","svelte-1bxmatr"),t(re,"class","svelte-1bxmatr"),t(ae,"class","svelte-1bxmatr"),t(N,"class","svelte-1bxmatr"),t(S,"class","svelte-1bxmatr"),t(W,"class","svelte-1bxmatr"),t(f,"class","svelte-1bxmatr"),t(v,"class","text svelte-1bxmatr"),t(C,"class","sub_header svelte-1bxmatr"),t(se,"class","svelte-1bxmatr"),t(le,"class","svelte-1bxmatr"),t(ne,"class","svelte-1bxmatr"),t(ie,"class","svelte-1bxmatr"),Mt(R,"width","25vw"),Gt(R.src,pt="/images/brainfuck/iterator.png")||t(R,"src",pt),t(R,"alt","Rust code showing iterator I used"),t(R,"class","svelte-1bxmatr"),t(b,"class","text svelte-1bxmatr"),t(P,"class","sub_header svelte-1bxmatr"),t(oe,"class","svelte-1bxmatr"),t(ce,"class","svelte-1bxmatr"),t(y,"class","text svelte-1bxmatr"),t(U,"class","sub_header svelte-1bxmatr"),t(he,"class","svelte-1bxmatr"),t(de,"class","svelte-1bxmatr"),t(B,"class","text svelte-1bxmatr"),t(o,"class","inner svelte-1bxmatr"),t(L,"class","content svelte-1bxmatr"),t(x,"class","svelte-1bxmatr")},m(m,Y){ut(m,I,Y),e(I,D),e(D,me),ut(m,Q,Y),ut(m,x,Y),Nt(w,x,null),e(x,ve),e(x,L),e(L,o),e(o,V),e(V,be),e(o,ge),e(o,F),e(F,fe),e(o,_e),e(o,g),e(g,Ie),e(g,X),e(g,Z),e(g,xe),e(g,u),e(u,T),e(T,ye),e(u,Be),e(u,$),e($,Ee),e(u,Re),e(u,q),e(q,we),e(u,ke),e(u,z),e(z,De),e(u,Le),e(u,A),e(A,Ve),e(u,Fe),e(u,O),e(O,Te),e(u,$e),e(u,H),e(H,qe),e(u,ze),e(u,M),e(M,Ae),e(g,Oe),e(o,He),e(o,G),e(G,Me),e(o,Ge),e(o,v),e(v,Ne),e(v,ee),e(v,te),e(v,Se),e(v,re),e(v,ae),e(v,We),e(v,f),e(f,N),e(N,Ce),e(f,Pe),e(f,S),e(S,Ue),e(f,Ye),e(f,W),e(W,je),e(v,Je),e(o,Ke),e(o,C),e(C,Qe),e(o,Xe),e(o,b),e(b,Ze),e(b,se),e(b,le),e(b,et),e(b,ne),e(b,ie),e(b,tt),e(b,R),e(o,rt),e(o,P),e(P,at),e(o,st),e(o,y),e(y,lt),e(y,oe),e(y,ce),e(y,nt),e(o,it),e(o,U),e(U,ot),e(o,ct),e(o,B),e(B,ht),e(B,he),e(B,de),e(B,dt),ue=!0},p:St,i(m){ue||(Wt(w.$$.fragment,m),ue=!0)},o(m){Ct(w.$$.fragment,m),ue=!1},d(m){m&&s(I),m&&s(Q),m&&s(x),Pt(w)}}}class Kt extends qt{constructor(I){super(),zt(this,I,null,Yt,At,{})}}export{Kt as default};
