import{S as Tt,i as $t,s as qt,k as r,q as a,a as h,w as zt,l as s,m as o,r as l,h as n,c as g,x as At,n as t,p as Ot,I as Ht,b as gt,G as e,y as Mt,B as Gt,f as Nt,t as St,z as Wt}from"../../../../chunks/index-13fba489.js";import{N as Ct}from"../../../../chunks/Navbar-d8336603.js";function Pt(xt){let _,L,ue,K,I,k,pe,i,F,fe,ve,V,ye,me,y,be,Q,X,_e,d,x,Ie,Be,T,Ee,Re,$,we,ke,q,De,Le,z,Fe,Ve,A,xe,Te,O,$e,qe,H,ze,Ae,Oe,M,He,Me,f,Ge,Z,ee,Ne,te,re,Se,m,G,We,Ce,N,Pe,Ue,S,Ye,je,Je,W,Ke,Qe,v,Xe,se,ae,Ze,le,ne,et,w,dt,tt,C,rt,st,B,at,oe,ie,lt,nt,P,ot,it,E,ct,ce,he,ht,ge;return k=new Ct({}),{c(){_=r("head"),L=r("title"),ue=a("Home"),K=h(),I=r("body"),zt(k.$$.fragment),pe=h(),i=r("div"),F=r("div"),fe=a("Brainf**k Interpreter"),ve=h(),V=r("div"),ye=a("What is Brainf**k?"),me=h(),y=r("div"),be=a(`Brainf**k (BF) is an esolang centred around a single array of bytes
            `),Q=r("br"),X=r("br"),_e=a(`
            There are only 8 operators in BF:
            `),d=r("ul"),x=r("li"),Ie=a("> Increment the pointer position"),Be=h(),T=r("li"),Ee=a("< Deincrement the pointer position"),Re=h(),$=r("li"),we=a("+ Increment the byte at the pointer"),ke=h(),q=r("li"),De=a("- Deincrement the byte at the pointer"),Le=h(),z=r("li"),Fe=a(". Output the byte at the data pointer"),Ve=h(),A=r("li"),xe=a(", Accept one byte of input, storing it in the byte at the pointer"),Te=h(),O=r("li"),$e=a("[ If the byte at the pointer is zero, goto the corresponding ] operator"),qe=h(),H=r("li"),ze=a("] If the byte at the pointer is nonzero, goto the corresponding [ operator"),Ae=a(`
            Despite only having these 8 operators BF is (with an infinitely large array) turing complete`),Oe=h(),M=r("div"),He=a("Implementing Brainf**k"),Me=h(),f=r("div"),Ge=a(`Around the time that I found out about BF I was also learning the programming language Rust
            `),Z=r("br"),ee=r("br"),Ne=a(`
            I decided to write my BF interpreter in Rust as it provided a great opportunity to start
            getting to grips with Rust's match statements and iterators
            `),te=r("br"),re=r("br"),Se=a(`
            My brainf**k interpreter has 3 main parts:
            `),m=r("ol"),G=r("li"),We=a("Read and parse the program"),Ce=h(),N=r("li"),Pe=a("Read input"),Ue=h(),S=r("li"),Ye=a("Interpret the program"),je=a(`
            Lets break down how I solved each of these presentations`),Je=h(),W=r("div"),Ke=a("Reading and parsing the program"),Qe=h(),v=r("div"),Xe=a(`The program functions as an interactive session interpreter,
            so it will keep taking lines of user input from the terminal until the user enters "run"
            `),se=r("br"),ae=r("br"),Ze=a(`
            For every line of user input the program will iterate through all the characters 
            and filter out any that aren't one of the 8 operators
            `),le=r("br"),ne=r("br"),et=h(),w=r("img"),tt=h(),C=r("div"),rt=a("Reading user input"),st=h(),B=r("div"),at=a(`I made the design decision of having all user input entered before the program is interpreted. 
            `),oe=r("br"),ie=r("br"),lt=a(`
            This meant that all input could be entered quickly on a single line`),nt=h(),P=r("div"),ot=a("Interpreting the program"),it=h(),E=r("div"),ct=a(`The program uses a while loop to keep running through the characters in the program 
            until the end has been reached
            `),ce=r("br"),he=r("br"),ht=a(`
            Inside the while loop a match statement is used to match the current 
            operator to the current code to run for that operator`),this.h()},l(p){_=s(p,"HEAD",{class:!0});var U=o(_);L=s(U,"TITLE",{class:!0});var ut=o(L);ue=l(ut,"Home"),ut.forEach(n),U.forEach(n),K=g(p),I=s(p,"BODY",{class:!0});var de=o(I);At(k.$$.fragment,de),pe=g(de),i=s(de,"DIV",{class:!0});var c=o(i);F=s(c,"DIV",{class:!0});var pt=o(F);fe=l(pt,"Brainf**k Interpreter"),pt.forEach(n),ve=g(c),V=s(c,"DIV",{class:!0});var ft=o(V);ye=l(ft,"What is Brainf**k?"),ft.forEach(n),me=g(c),y=s(c,"DIV",{class:!0});var D=o(y);be=l(D,`Brainf**k (BF) is an esolang centred around a single array of bytes
            `),Q=s(D,"BR",{class:!0}),X=s(D,"BR",{class:!0}),_e=l(D,`
            There are only 8 operators in BF:
            `),d=s(D,"UL",{class:!0});var u=o(d);x=s(u,"LI",{class:!0});var vt=o(x);Ie=l(vt,"> Increment the pointer position"),vt.forEach(n),Be=g(u),T=s(u,"LI",{class:!0});var yt=o(T);Ee=l(yt,"< Deincrement the pointer position"),yt.forEach(n),Re=g(u),$=s(u,"LI",{class:!0});var mt=o($);we=l(mt,"+ Increment the byte at the pointer"),mt.forEach(n),ke=g(u),q=s(u,"LI",{class:!0});var bt=o(q);De=l(bt,"- Deincrement the byte at the pointer"),bt.forEach(n),Le=g(u),z=s(u,"LI",{class:!0});var _t=o(z);Fe=l(_t,". Output the byte at the data pointer"),_t.forEach(n),Ve=g(u),A=s(u,"LI",{class:!0});var It=o(A);xe=l(It,", Accept one byte of input, storing it in the byte at the pointer"),It.forEach(n),Te=g(u),O=s(u,"LI",{class:!0});var Bt=o(O);$e=l(Bt,"[ If the byte at the pointer is zero, goto the corresponding ] operator"),Bt.forEach(n),qe=g(u),H=s(u,"LI",{class:!0});var Et=o(H);ze=l(Et,"] If the byte at the pointer is nonzero, goto the corresponding [ operator"),Et.forEach(n),u.forEach(n),Ae=l(D,`
            Despite only having these 8 operators BF is (with an infinitely large array) turing complete`),D.forEach(n),Oe=g(c),M=s(c,"DIV",{class:!0});var Rt=o(M);He=l(Rt,"Implementing Brainf**k"),Rt.forEach(n),Me=g(c),f=s(c,"DIV",{class:!0});var b=o(f);Ge=l(b,`Around the time that I found out about BF I was also learning the programming language Rust
            `),Z=s(b,"BR",{class:!0}),ee=s(b,"BR",{class:!0}),Ne=l(b,`
            I decided to write my BF interpreter in Rust as it provided a great opportunity to start
            getting to grips with Rust's match statements and iterators
            `),te=s(b,"BR",{class:!0}),re=s(b,"BR",{class:!0}),Se=l(b,`
            My brainf**k interpreter has 3 main parts:
            `),m=s(b,"OL",{class:!0});var Y=o(m);G=s(Y,"LI",{class:!0});var wt=o(G);We=l(wt,"Read and parse the program"),wt.forEach(n),Ce=g(Y),N=s(Y,"LI",{class:!0});var kt=o(N);Pe=l(kt,"Read input"),kt.forEach(n),Ue=g(Y),S=s(Y,"LI",{class:!0});var Dt=o(S);Ye=l(Dt,"Interpret the program"),Dt.forEach(n),Y.forEach(n),je=l(b,`
            Lets break down how I solved each of these presentations`),b.forEach(n),Je=g(c),W=s(c,"DIV",{class:!0});var Lt=o(W);Ke=l(Lt,"Reading and parsing the program"),Lt.forEach(n),Qe=g(c),v=s(c,"DIV",{class:!0});var R=o(v);Xe=l(R,`The program functions as an interactive session interpreter,
            so it will keep taking lines of user input from the terminal until the user enters "run"
            `),se=s(R,"BR",{class:!0}),ae=s(R,"BR",{class:!0}),Ze=l(R,`
            For every line of user input the program will iterate through all the characters 
            and filter out any that aren't one of the 8 operators
            `),le=s(R,"BR",{class:!0}),ne=s(R,"BR",{class:!0}),et=g(R),w=s(R,"IMG",{style:!0,src:!0,alt:!0,class:!0}),R.forEach(n),tt=g(c),C=s(c,"DIV",{class:!0});var Ft=o(C);rt=l(Ft,"Reading user input"),Ft.forEach(n),st=g(c),B=s(c,"DIV",{class:!0});var j=o(B);at=l(j,`I made the design decision of having all user input entered before the program is interpreted. 
            `),oe=s(j,"BR",{class:!0}),ie=s(j,"BR",{class:!0}),lt=l(j,`
            This meant that all input could be entered quickly on a single line`),j.forEach(n),nt=g(c),P=s(c,"DIV",{class:!0});var Vt=o(P);ot=l(Vt,"Interpreting the program"),Vt.forEach(n),it=g(c),E=s(c,"DIV",{class:!0});var J=o(E);ct=l(J,`The program uses a while loop to keep running through the characters in the program 
            until the end has been reached
            `),ce=s(J,"BR",{class:!0}),he=s(J,"BR",{class:!0}),ht=l(J,`
            Inside the while loop a match statement is used to match the current 
            operator to the current code to run for that operator`),J.forEach(n),c.forEach(n),de.forEach(n),this.h()},h(){t(L,"class","svelte-1gogytf"),t(_,"class","svelte-1gogytf"),t(F,"class","title svelte-1gogytf"),t(V,"class","header svelte-1gogytf"),t(Q,"class","svelte-1gogytf"),t(X,"class","svelte-1gogytf"),t(x,"class","svelte-1gogytf"),t(T,"class","svelte-1gogytf"),t($,"class","svelte-1gogytf"),t(q,"class","svelte-1gogytf"),t(z,"class","svelte-1gogytf"),t(A,"class","svelte-1gogytf"),t(O,"class","svelte-1gogytf"),t(H,"class","svelte-1gogytf"),t(d,"class","no_dot svelte-1gogytf"),t(y,"class","text svelte-1gogytf"),t(M,"class","header svelte-1gogytf"),t(Z,"class","svelte-1gogytf"),t(ee,"class","svelte-1gogytf"),t(te,"class","svelte-1gogytf"),t(re,"class","svelte-1gogytf"),t(G,"class","svelte-1gogytf"),t(N,"class","svelte-1gogytf"),t(S,"class","svelte-1gogytf"),t(m,"class","svelte-1gogytf"),t(f,"class","text svelte-1gogytf"),t(W,"class","sub_header svelte-1gogytf"),t(se,"class","svelte-1gogytf"),t(ae,"class","svelte-1gogytf"),t(le,"class","svelte-1gogytf"),t(ne,"class","svelte-1gogytf"),Ot(w,"width","25vw"),Ht(w.src,dt="/images/brainfuck/iterator.png")||t(w,"src",dt),t(w,"alt","Rust code showing iterator I used"),t(w,"class","svelte-1gogytf"),t(v,"class","text svelte-1gogytf"),t(C,"class","sub_header svelte-1gogytf"),t(oe,"class","svelte-1gogytf"),t(ie,"class","svelte-1gogytf"),t(B,"class","text svelte-1gogytf"),t(P,"class","sub_header svelte-1gogytf"),t(ce,"class","svelte-1gogytf"),t(he,"class","svelte-1gogytf"),t(E,"class","text svelte-1gogytf"),t(i,"class","content svelte-1gogytf"),t(I,"class","svelte-1gogytf")},m(p,U){gt(p,_,U),e(_,L),e(L,ue),gt(p,K,U),gt(p,I,U),Mt(k,I,null),e(I,pe),e(I,i),e(i,F),e(F,fe),e(i,ve),e(i,V),e(V,ye),e(i,me),e(i,y),e(y,be),e(y,Q),e(y,X),e(y,_e),e(y,d),e(d,x),e(x,Ie),e(d,Be),e(d,T),e(T,Ee),e(d,Re),e(d,$),e($,we),e(d,ke),e(d,q),e(q,De),e(d,Le),e(d,z),e(z,Fe),e(d,Ve),e(d,A),e(A,xe),e(d,Te),e(d,O),e(O,$e),e(d,qe),e(d,H),e(H,ze),e(y,Ae),e(i,Oe),e(i,M),e(M,He),e(i,Me),e(i,f),e(f,Ge),e(f,Z),e(f,ee),e(f,Ne),e(f,te),e(f,re),e(f,Se),e(f,m),e(m,G),e(G,We),e(m,Ce),e(m,N),e(N,Pe),e(m,Ue),e(m,S),e(S,Ye),e(f,je),e(i,Je),e(i,W),e(W,Ke),e(i,Qe),e(i,v),e(v,Xe),e(v,se),e(v,ae),e(v,Ze),e(v,le),e(v,ne),e(v,et),e(v,w),e(i,tt),e(i,C),e(C,rt),e(i,st),e(i,B),e(B,at),e(B,oe),e(B,ie),e(B,lt),e(i,nt),e(i,P),e(P,ot),e(i,it),e(i,E),e(E,ct),e(E,ce),e(E,he),e(E,ht),ge=!0},p:Gt,i(p){ge||(Nt(k.$$.fragment,p),ge=!0)},o(p){St(k.$$.fragment,p),ge=!1},d(p){p&&n(_),p&&n(K),p&&n(I),Wt(k)}}}class jt extends Tt{constructor(_){super(),$t(this,_,null,Pt,qt,{})}}export{jt as default};
